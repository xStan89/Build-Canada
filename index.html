<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bad Boys</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --info-bg: #0b1220;
      --info-text: #ffffff;
    }
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:var(--bg); }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg); }
    canvas { width:100%; height:100%; display:block; background:var(--bg); }

    /* TOP CONTROLS - ZOOM */
    #top-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    #zoom-controls {
      display: flex;
      gap: 8px;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #494949;
      color: #fff;
      font-size: 14px;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .zoom-btn:hover {
      background: #5a5a5a;
    }
    
    .zoom-btn:active {
      background: #3a3a3a;
    }

    /* INFO PANEL */
    #info-panel {
      width:320px; min-width:260px; max-width:360px;
      background: var(--info-bg); color: var(--info-text);
      padding:12px; box-sizing:border-box;
      display:flex; flex-direction:column;
      border-left: 1px solid rgba(255,255,255,0.04);
      font-size:13px;
      height: 100vh;
      overflow: hidden;
    }
    
    /* WIKIPEDIA PANEL */
    #wiki-panel {
      width:320px; min-width:260px; max-width:360px;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #ccc;
    }

    #wiki-header {
      background: #f8f9fa;
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #wiki-close {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    #wiki-iframe {
      flex: 1;
      border: none;
      width: 100%;
    }

    @media (max-width: 1200px) { 
      #wiki-panel { width: 400px; }
      #wiki-panel.visible ~ #info-panel { display: none; }
    }
    
    #controls { 
      display:flex; 
      gap:8px; 
      align-items:center; 
      flex-shrink: 0; 
      margin-bottom: 8px;
    }
    #search-box { display:flex; width:100%; gap:6px; }
    #search-input { flex:1; padding:6px 8px; border-radius:4px; border:1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); color:inherit; }
    #search-btn, #clear-btn { padding:6px 8px; border-radius:4px; border:none; cursor:pointer; background:#494949; color:#fff; }
    #colorby-select { width:100%; padding:6px 8px; border-radius:4px; border:none; background:#0b1220; color:inherit; }

    #suggestions { background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); max-height:160px; overflow:auto; display:none; padding:6px; border-radius:4px; }
    .suggestion { padding:6px; cursor:pointer; border-bottom:1px dashed rgba(255,255,255,0.03); }
    .suggestion:hover { background: rgba(255,255,255,0.03); }

    #node-info { 
      margin-top:8px; 
      padding:8px; 
      background: rgba(255,255,255,0.02); 
      border-radius:6px; 
      flex-shrink: 0;
    }
    #node-title { font-weight:700; }
    .muted { color:#454545; font-size:13px;  font-weight:700;}

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top:8px;
      background: rgba(255,255,255,0.02);
      border-radius:6px;
      padding:6px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.03);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding:6px;
      cursor:pointer;
      font-size:13px;
      color:var(--info-text);
      border-bottom:1px dashed rgba(255,255,255,0.03);
    }
    .conn-item:hover { background: rgba(255,255,255,0.03); }

    #msg { margin-top:6px; color:#fca5a5; font-size:13px; min-height:18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position:fixed; left:0; top:0; right:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column; gap:10px;
      background: rgba(255,255,255,0.7);
      z-index:99999;
      font-size:16px; color:#111827;
    }
    .spinner {
      width:44px; height:44px;
      border-radius:50%;
      border:5px solid rgba(0,0,0,0.08);
      border-left-color:#eb2525;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* responsive */
    @media (max-width: 900px) { #info-panel { width:260px; } }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="top-controls">
        <div id="zoom-controls">
          <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
          <button id="zoom-out" class="zoom-btn" title="Zoom Out">-</button>
          <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">Reset</button>
        </div>
      </div>

      <div id="loading-overlay" aria-hidden="false">
        <div class="spinner" role="img" aria-label="loading"></div>
        <div id="loading-text">This takes a few seconds...</div>
      </div>
    </div>

      <aside id="info-panel" style="--info-bg:var(--info-bg); --info-text:var(--info-text);">
        <div id="controls">
          <div id="search-box">
            <input id="search-input" placeholder="Search a person or group..." />
            <button id="search-btn">Search</button>
          </div>
        </div>

        <button id="clear-btn" style="margin-bottom: 8px; flex-shrink: 0;">Clear Selection</button>

        <div id="suggestions"></div>

        <div id="node-info">
          <div id="node-title"></div>
          <div id="node-meta" class="muted" style="margin-top:6px;"></div>
        </div>

        <div id="node-links">
          <!-- Wikipedia/More Info links will go here -->
        </div>

        <div id="connections-box" aria-live="polite"></div>

        <div id="msg"></div>
      </aside>

      <aside id="wiki-panel">
        <div id="wiki-header">
          <div id="wiki-title">More Info</div>
          <button id="wiki-close">Ã—</button>
        </div>
        <iframe id="wiki-iframe" src="about:blank"></iframe>
      </aside>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    LINKS_CSV: './Links.csv',
    POINTS_CSV: './Labels.csv',

    backgroundColor: '#ffffff',
    defaultPointColor: '#791F1F',
    colorPalette: d3.schemeTableau10,
    pointOpacity: 0.8,
    unconnectedOpacity: 0.18,
    linkColor: '#9ca3af',
    linkOpacityNoSelection: 0.2,
    linkOpacitySelected: 0.5,
    pointStrokeColor: '791F1F',
    pointStrokeWidth: 2,

    labelFontSize: 14,
    labelBoxPadding: 4,
    labelOffsetY: 4,
    labelBoxOpacity: 0.5,

    sizeByField: 'Size',
    sizeMin: 0.2,
    sizeMax: 30,
    sizeRangeFactor: 3,

    force: {
      linkDistance: 50,
      linkStrength: 2.0,
      chargeStrength: -100,
      collisionPadding: 2.5,
      velocityDecay: 0.3
    },

    preTickSmall: 200,
    preTickMedium: 100,
    preTickLarge: 50,

    velThreshold: 0.035,
    stableTicksNeeded: 16,
    maxLoadingSeconds: 6,

    showImages: true,
    maxSuggestions: 12,
    
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2
  };
  /************************************************************************
   * END CONFIG
   ************************************************************************/
  
  const PADDING = 80;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;
  
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    ctx.setTransform(hiResScale, 0, 0, hiResScale, 0, 0);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener('resize', () => { resizeCanvas(); if (simulation && simulation.force) { const c = simulation.force('center'); if (c) c.x = (canvas.width/devicePixelRatio)/2, c.y = (canvas.height/devicePixelRatio)/2; } });
  resizeCanvas();

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');

  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');

  const wikiPanel = document.getElementById('wiki-panel');
  const wikiTitle = document.getElementById('wiki-title');
  const wikiIframe = document.getElementById('wiki-iframe');
  const wikiClose = document.getElementById('wiki-close');

  let nodes = [];
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let connectionSources = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let isStable = false;
  let imageLoadPromises = [];
  const categoricalColor = d3.scaleOrdinal(CONFIG.colorPalette);

  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  function updateCanvasCursor() {
    if (isDragging) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);

  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function computePreTicks(nCount) {
    if (nCount <= 500) return CONFIG.preTickSmall;
    if (nCount <= 2000) return CONFIG.preTickMedium;
    return CONFIG.preTickLarge;
  }

  function showWikipediaPanel(url, nodeName) {
    if (!url) return;
    wikiTitle.textContent = `Info Panel: ${nodeName}`;
    wikiIframe.src = url;
  }

  function hideWikipediaPanel() {
    wikiTitle.textContent = 'Info Panel';
    wikiIframe.src = 'about:blank';
  }

  wikiClose.addEventListener('click', hideWikipediaPanel);

  loadingOverlay.style.display = 'flex';

  requestAnimationFrame(() => {
    Promise.all([ d3.csv(CONFIG.LINKS_CSV), d3.csv(CONFIG.POINTS_CSV) ])
      .then(([rawLinks, rawPoints]) => {
        rawPoints.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });
        rawLinks.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });

        nodes = rawPoints.map((d,i) => {
          const id = d['Entity Name'] ? String(d['Entity Name']).trim() : `__P_${i}`;
          const rawSize = (d[CONFIG.sizeByField] || '').toString().replace('%','').trim();
          const sizeVal = parseFloat(rawSize) || 0;
          return {
            id, name: id, raw: d, sizeVal,
            image: d['Image'] ? d['Image'].trim() : null, imageBitmap: null,
            x: Math.random() * (canvas.width/devicePixelRatio), y: Math.random() * (canvas.height/devicePixelRatio),
            vx: 0, vy: 0, r: CONFIG.sizeMin
          };
        });

        nodeById = new Map(nodes.map(n => [n.id, n]));

        const tmpLinks = (rawLinks || []).map(r => ({
          sourceName: (r['A']||'').toString().trim(),
          targetName: (r['B']||'').toString().trim(),
          value: +((r['Link Size']||r['LinkSize']) || 1) || 1,
          source: (r['Source']||'').toString().trim()
        })).filter(l => l.sourceName && l.targetName);

        tmpLinks.forEach(l => {
          if (!nodeById.has(l.sourceName)) {
            const n = { id: l.sourceName, name: l.sourceName, raw: {}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
          if (!nodeById.has(l.targetName)) {
            const n = { id: l.targetName, name: l.targetName, raw:{}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
        });

        links = tmpLinks.map(l => ({ 
          source: nodeById.get(l.sourceName), 
          target: nodeById.get(l.targetName), 
          value: l.value,
          sourceUrl: l.source
        })).filter(l => l.source && l.target);

        adjacency = new Map(); 
        connectionSources = new Map();
        nodes.forEach(n => {
          adjacency.set(n.id, new Set());
          connectionSources.set(n.id, new Map());
        });
        links.forEach(l => {
          adjacency.get(l.source.id).add(l.target.id);
          adjacency.get(l.target.id).add(l.source.id);
          
          if (l.sourceUrl) {
            connectionSources.get(l.source.id).set(l.target.id, l.sourceUrl);
            connectionSources.get(l.target.id).set(l.source.id, l.sourceUrl);
          }
        });

        nameIndex = nodes.map(n => n.name);

        const vals = nodes.map(n => n.sizeVal || 0);
        const vmin = d3.min(vals) || 0;
        const vmax = d3.max(vals) || 1;
        const baseScale = d3.scaleSqrt().domain([vmin, vmax]).range([CONFIG.sizeMin, CONFIG.sizeMax]);
        nodes.forEach(n => {
          const base = baseScale(n.sizeVal || 0);
          const r = CONFIG.sizeMin + (base - CONFIG.sizeMin) * CONFIG.sizeRangeFactor;
          n.r = Math.max(CONFIG.sizeMin, Math.min(r, CONFIG.sizeMax * CONFIG.sizeRangeFactor * 1.5));
        });

        const linkValues = links.map(l => l.value || 1);
        const linkWidthScale = d3.scaleLinear().domain([d3.min(linkValues) || 1, d3.max(linkValues) || 1]).range([0.6, 4]).clamp(true);
        window.__linkWidthScale = linkWidthScale;

        const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
        imageLoadPromises = imgNodes.map(n => {
          return new Promise(async resolve => {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 7000);
              const resp = await fetch(n.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
              clearTimeout(timeoutId);
              if (!resp || !resp.ok) throw new Error('fetch failed');
              const blob = await resp.blob();
              if (typeof createImageBitmap === 'function') {
                try {
                  const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
                  n.imageBitmap = bmp;
                  resolve({n,ok:true});
                  return;
                } catch (e) {
                }
              }
              const img = new Image();
              img.onload = () => { n.imageBitmap = img; resolve({n,ok:true}); };
              img.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
              img.src = URL.createObjectURL(blob);
              setTimeout(() => { if (!n.imageBitmap) { n.imageBitmap = null; resolve({n,ok:false}); } }, 7000);
            } catch (err) {
              try {
                const img2 = new Image();
                img2.onload = () => { n.imageBitmap = img2; resolve({n,ok:true}); };
                img2.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
                img2.src = n.image;
                setTimeout(() => { if (!n.imageBitmap) resolve({n,ok:false}); }, 7000);
              } catch (e) {
                n.imageBitmap = null;
                resolve({n,ok:false});
              }
            }
          });
        });

        simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id)
            .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
            .strength(CONFIG.force.linkStrength))
          .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
          .force('center', d3.forceCenter((canvas.width/devicePixelRatio)/2, (canvas.height/devicePixelRatio)/2))
          .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
          .velocityDecay(CONFIG.force.velocityDecay);

        const preTicks = computePreTicks(nodes.length);
        simulation.stop();
        for (let i=0;i<preTicks;i++) simulation.tick();

        render();

        let stableCount = 0;
        const velThreshold = CONFIG.velThreshold;
        const stableNeeded = CONFIG.stableTicksNeeded;
        const startTime = Date.now();
        let forcedHideTimer = setTimeout(() => {
          if (!isStable) {
            if (simulation) simulation.stop();
            isStable = true;
            hideLoadingOverlay();
            render();
          }
        }, CONFIG.maxLoadingSeconds * 1000);

        simulation.on('tick', () => {
          nodes.forEach(n => {
            n.x = Math.max(n.r + PADDING, Math.min((canvas.width/devicePixelRatio) - n.r - PADDING, n.x));
            n.y = Math.max(n.r + PADDING, Math.min((canvas.height/devicePixelRatio) - n.r - PADDING, n.y));
          });

          let maxSpeed = 0;
          for (const n of nodes) {
            const speed = Math.hypot(n.vx||0, n.vy||0);
            if (speed > maxSpeed) maxSpeed = speed;
          }

          if (maxSpeed < velThreshold) stableCount++; else stableCount = 0;
          render();

          if (!isStable && stableCount >= stableNeeded) {
            isStable = true;
            simulation.stop();
            hideLoadingOverlay();
            clearTimeout(forcedHideTimer);
          }
        });

        simulation.alpha(0.3).restart();

        Promise.allSettled(imageLoadPromises).then(() => { render(); });

      }).catch(err => {
        console.error('CSV load error', err);
        loadingText.textContent = 'Failed to load CSV files â€“ check paths and console.';
        setTimeout(() => { loadingOverlay.style.display = 'none'; }, 8000);
      });
  });

  function clearCanvas() {
    ctx.fillStyle = CONFIG.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
  }

  function applyTransform() {
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = (window.__linkWidthScale ? window.__linkWidthScale(l.value) : 1) / zoomLevel;
    ctx.strokeStyle = CONFIG.linkColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    ctx.globalAlpha = opacity;
    const x = n.x, y = n.y, r = n.r;

    if (showImage && n.imageBitmap) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = getNodeFill(n);
        ctx.fill();
      }
      ctx.restore();
      ctx.save();
    } else {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = getNodeFill(n);
      ctx.fill();
    }

    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = CONFIG.pointStrokeWidth / zoomLevel;
    ctx.strokeStyle = CONFIG.pointStrokeColor;
    ctx.stroke();

    ctx.restore();
  }

  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px ${CONFIG.labelTextFont || 'Arial, sans-serif'}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function getNodeFill(n) {
    return CONFIG.defaultPointColor;
  }

  function shouldHighlightNode(node) {
    const activeNode = selectedNode;
    if (!activeNode) return true;
    
    const activeSet = new Set([activeNode.id, ...(adjacency.get(activeNode.id) || [])]);
    return activeSet.has(node.id);
  }

  function render() {
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    const activeNode = selectedNode;
    
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    nodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    if (activeNode) {
      const highlightedSet = new Set(highlightedNodes.map(n => n.id));
      links.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      const highlightedSet = new Set(highlightedNodes.map(n => n.id));
      links.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacityNoSelection);
        }
      });
    }

    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    if (activeNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(activeNode.id).has(n.id) || n === activeNode) {
          drawLabel(n);
        }
      });
    }

    ctx.restore();
  }

  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / devicePixelRatio) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / devicePixelRatio) / rect.height;
    
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = nodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = nodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  canvas.addEventListener('mousedown', (evt) => {
    if (zoomLevel <= 1.0) return;
    
    isDragging = true;
    updateCanvasCursor();
    
    dragStartX = evt.clientX;
    dragStartY = evt.clientY;
    dragStartPanX = panX;
    dragStartPanY = panY;
    
    evt.preventDefault();
  });

  canvas.addEventListener('mousemove', (evt) => {
    if (!isDragging || zoomLevel <= 1.0) {
      updateCanvasCursor();
      return;
    }
    
    const deltaX = evt.clientX - dragStartX;
    const deltaY = evt.clientY - dragStartY;
    
    panX = dragStartPanX + deltaX / zoomLevel;
    panY = dragStartPanY + deltaY / zoomLevel;
    
    render();
    evt.preventDefault();
  });

  canvas.addEventListener('mouseup', (evt) => {
    if (isDragging) {
      const deltaX = Math.abs(evt.clientX - dragStartX);
      const deltaY = Math.abs(evt.clientY - dragStartY);
      
      isDragging = false;
      updateCanvasCursor();
      
      if (deltaX < 3 && deltaY < 3) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          selectedNode = n;
          populateInfoPanel(n);
          render();
        } else {
          selectedNode = null;
          clearInfoPanel();
          render();
        }
      }
      evt.preventDefault();
    }
  });

  canvas.addEventListener('click', (evt) => {
    if (zoomLevel > 1.0 || isDragging) return;
    
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      populateInfoPanel(n);
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    isDragging = false;
    updateCanvasCursor();
  });

  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:1400;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
    `);

    nodeMetaEl.html(category.replace(/\n/g, '<br>'));
    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['More Info'] || d.raw['More Info'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe)      links.push(`<a href="${safe}" target="_blank" rel="noopener">Wikipedia</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">More Info</a>`);
    nodeLinkEl.html(links.join(' | '));

    if (safe) {
      showWikipediaPanel(safe, d.name);
    }

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      nameSpan.textContent = name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          render();
          connectionsBox.scrollTop = 0;
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = 'ðŸ”—';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.text('');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
    hideWikipediaPanel();
  }

  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { performSearch(searchInput.value.trim()); ev.preventDefault(); } });

  clearBtn.addEventListener('click', () => { 
    selectedNode = null; 
    clearInfoPanel(); 
    render(); 
    searchInput.value = ''; 
    suggestionsEl.style('display', 'none').html(''); 
    msgEl.text('');
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; populateInfoPanel(exact); render(); d3.select('#msg').text(''); return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; populateInfoPanel(matches[0]); render(); d3.select('#msg').text(''); return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          render();
        });
      });
      d3.select('#msg').text('Multiple matches â€“ click a suggestion.'); return;
    } else {
      d3.select('#msg').text('Search term not found. Please try again.');
    }
  }

  function hideLoadingOverlay() { loadingOverlay.style.display = 'none'; }

  setTimeout(() => {
    if (!isStable) {
      if (simulation) simulation.stop();
      isStable = true;
      hideLoadingOverlay();
      render();
    }
  }, (CONFIG.maxLoadingSeconds + 3) * 1000);

  window.__fdg = { nodes, links, CONFIG, render, zoomLevel, panX, panY };
  </script>
</body>
</html>